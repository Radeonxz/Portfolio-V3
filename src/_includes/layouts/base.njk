<!DOCTYPE html>
<html lang="{{ locale }}" class="dark-theme">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel='icon' href='/assets/favicon-32x32-dark.png' type='image/x-icon'/
    >
    <link rel="stylesheet" href="/style.css" />

    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
      integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm"
      crossorigin="anonymous"
    />
    <link
      href="https://bootswatch.com/5/darkly/bootstrap.min.css"
      crossorigin="anonymous"
      rel="stylesheet"
    />
    <link id="light-theme-style" rel="stylesheet" />
    <link id="light-favicon" rel="icon" type="image/x-icon" />
    <title>{{ title }}</title>
  </head>
  <body>
    {% include 'partials/header.njk' %}
    <main>
      {{ content | safe }}
    </main>
    {% include 'partials/footer.njk' %}

    <script
      src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"
      integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF"
      crossorigin="anonymous"
    ></script>

    <!-- Custom JavaScript  -->
    <script>
      const LOCAL_STORAGE_THEME_KEY = "app-theme";
      const LOCAL_STORAGE_LOCALE_KEY = "app-locale";
      const LOCAL_META_DATA_THEME = JSON.parse(
        localStorage.getItem(LOCAL_STORAGE_THEME_KEY)
      );
      const LOCAL_META_DATA_LOCALE = JSON.parse(
        localStorage.getItem(LOCAL_STORAGE_LOCALE_KEY)
      );

      // Get locale from url
      const urlLocale = window.location.pathname.split("/")[1];
      console.log("urlLocale: ", urlLocale);

      // Bootstrap light theme url
      const LIGHT_THEME_PATH =
        "https://bootswatch.com/5/quartz/bootstrap.min.css";
      const LIGHT_FAVICON_PATH = "/assets/favicon-32x32-light.png";
      const LIGHT_STYLE_LINK = document.getElementById("light-theme-style");
      const LIGHT_FAVICON = document.getElementById("light-favicon");
      const THEME_SWITCH = document.getElementById("theme-switch");
      let isLight = LOCAL_META_DATA_THEME && LOCAL_META_DATA_THEME.isLight;
      // check if user has already selected light theme earlier
      if (isLight) {
        enableLightTheme();
      } else {
        disableLightTheme();
      }

      function toggleTheme() {
        isLight = !isLight;
        if (isLight) {
          enableLightTheme();
        } else {
          disableLightTheme();
        }
        const META = { isLight };
        localStorage.setItem(LOCAL_STORAGE_THEME_KEY, JSON.stringify(META));
      }
      function enableLightTheme() {
        document.documentElement.className = "light-theme";
        LIGHT_STYLE_LINK.setAttribute("href", LIGHT_THEME_PATH);
        LIGHT_FAVICON.setAttribute("href", LIGHT_FAVICON_PATH);
        THEME_SWITCH.innerHTML = '<i class="far fa-moon"></i>'; // ðŸŒ™
      }
      function disableLightTheme() {
        document.documentElement.className = "dark-theme";
        LIGHT_STYLE_LINK.setAttribute("href", "");
        LIGHT_FAVICON.setAttribute("href", "");
        THEME_SWITCH.innerHTML = '<i class="far fa-sun"></i>'; // ðŸ”†
      }

      // Menu logo script
      const parentEle = document.getElementById("menu-canvas");
      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");
      const layers = 8; // 4
      let size = 0;
      let particles = [];
      let targets = [];
      const lerp = (t, v0, v1) => (1 - t) * v0 + t * v1;
      const fov = 2000;
      const viewDistance = 100; // 200
      let targetRotationY = 0.5;
      let rotationY = 0.5;
      let speed = 40;
      let animFrame;
      let textIndex = 0;

      canvas.width = parentEle.offsetWidth;
      canvas.height = parentEle.offsetHeight;

      class Vector3 {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        static fromScreenCoords(_x, _y, _z) {
          const factor = fov / viewDistance;
          const x = (_x - canvas.width / 2) / factor;
          const y = (_y - canvas.height / 2) / factor;
          const z = _z !== undefined ? _z : 0;

          return new Vector3(x, y, z);
        }

        rotateX(angle) {
          const z = this.z * Math.cos(angle) - this.x * Math.sin(angle);
          const x = this.z * Math.sin(angle) + this.x * Math.cos(angle);
          return new Vector3(x, this.y, z);
        }
        rotateY(angle) {
          const y = this.y * Math.cos(angle) - this.z * Math.sin(angle);
          const z = this.y * Math.sin(angle) + this.z * Math.cos(angle);
          return new Vector3(this.x, y, z);
        }
        pp() {
          const factor = fov / (viewDistance + this.z);
          const x = this.x * factor + canvas.width / 2;
          const y = this.y * factor + canvas.height / 2;
          return new Vector3(x, y, this.z);
        }
      }

      function init(e) {
        if (e) e.preventDefault();
        cancelAnimationFrame(animFrame);
        const text = "Xuan.Z";
        let fontSize = 150;
        let startX = parentEle.offsetWidth / 2;
        let startY = parentEle.offsetHeight / 2;
        particles = [];
        targets = [];
        // Create temp canvas for the text, draw it and get the image data
        const c = document.createElement("canvas");
        const cx = c.getContext("2d");
        cx.font = `900 ${fontSize}px Arial`;
        let w = cx.measureText(text).width;
        const h = fontSize * 1.5;
        let gap = 7;

        // Adjust font and particle size to fit text on screen
        while (w > window.innerWidth * 0.8) {
          fontSize -= 1;
          cx.font = `900 ${fontSize}px Arial`;
          w = cx.measureText(text).width;
        }
        if (fontSize < 100) gap = 6;
        if (fontSize < 70) gap = 4;
        if (fontSize < 40) gap = 2;
        size = Math.max(gap / 2, 1);
        c.width = w;
        c.height = h;
        startX = Math.floor(startX - w / 2);
        startY = Math.floor(startY - h / 2);
        cx.fillStyle = "#000";
        cx.font = `900 ${fontSize}px Arial`;
        cx.fillText(text, 0, fontSize);
        const data = cx.getImageData(0, 0, w, h);

        // Iterate the image data and determine target coordinates for the flying particles
        for (let i = 0; i < data.data.length; i += 4) {
          const rw = data.width * 4;
          const rh = data.height * 4;
          const x = startX + Math.floor((i % rw) / 4);
          const y = startY + Math.floor(i / rw);

          if (data.data[i + 3] > 0 && x % gap === 0 && y % gap === 0) {
            for (let j = 0; j < layers; j++) {
              targets.push(Vector3.fromScreenCoords(x, y, j * 1));
            }
          }
        }

        targets = targets.sort((a, b) => a.x - b.x);
        loop();
        return false;
      }

      function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // As long as there are targets, keep creating new particles
        // Remove target from the targets array when it's been assigned to a particle
        for (let i = 0; i < speed; i++) {
          if (targets.length > 0) {
            target = targets[0];
            x = canvas.width / 2 + target.x * 10;
            y = canvas.height / 2;
            z = -10;

            const position = Vector3.fromScreenCoords(x, y, z);
            const interpolant = 0;

            particles.push({ position, target, interpolant });
            targets.splice(0, 1);
          }
        }

        particles
          .sort((pa, pb) => pb.target.z - pa.target.z)
          .forEach((p, i) => {
            if (p.interpolant < 1) {
              p.interpolant = Math.min(p.interpolant + 0.01, 1);

              p.position.x = lerp(p.interpolant, p.position.x, p.target.x);
              p.position.y = lerp(p.interpolant, p.position.y, p.target.y);
              p.position.z = lerp(p.interpolant, p.position.z, p.target.z);
            }
            const rotationX = Math.sin(Date.now() / 2000) * 0.8;
            rotationY = lerp(0.00001, rotationY, targetRotationY);
            const particle = p.position
              .rotateX(rotationX)
              .rotateY(rotationY)
              .pp();

            const s = 1 - p.position.z / layers;

            const firstLayer = isLight
              ? "rgb(248, 131, 121)"
              : "rgb(121, 175, 248)";
            const childLayer = isLight
              ? `rgba(121, 175, 248, ${s})`
              : `rgba(248, 131, 121, ${s})`;

            ctx.fillStyle = p.target.z === 0 ? firstLayer : childLayer;

            ctx.fillRect(particle.x, particle.y, s * size, s * size);
          });

        animFrame = requestAnimationFrame(loop);
      }

      init();

      // Add mousemove event to canvas only
      canvas.addEventListener("mousemove", (e) => {
        const halfHeight = parentEle.offsetHeight / 2;
        targetRotationY = (e.clientY - halfHeight) / parentEle.offsetHeight;
      });
    </script>
  </body>
</html>
